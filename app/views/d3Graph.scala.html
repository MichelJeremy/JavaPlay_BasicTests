@(list: List[String])

<!DOCTYPE html>
<html lang="en">
    <head>
        <title>WHAT ARE YOU DOING STALKER</title>
        <link rel="stylesheet" media="screen" href="@routes.Assets.versioned("stylesheets/main.css")">
        <link href="@routes.Assets.versioned("stylesheets/css/bootstrap.min.css")" rel="stylesheet">
        <link href="http://getbootstrap.com/examples/justified-nav/justified-nav.css" rel="stylesheet">
        <script src="@routes.Assets.versioned("javascripts/d3.min.js")" type="text/javascript"></script>
    </head>
    
    <body>
        <!-- Create two empty Object array and append as much unmutable array to it as there are values in the cvs document-->
        <script type="text/javascript">
            //First, let's see how many sensors there are
            var listOfSensorId = [];
            var alreadyExists = false;
            var i;
            // goes through every members of the data arraylist
            @for(l <- 0 until list.size) {
                // checks every 4 members, except the ery first which is text (= every Ids)
                
                @if(l%4 == 0 && l != 0) {
                    // checks every embers of listofSensorId
                    for(i = 0; i < listOfSensorId.length; i++) {
                        // if the list members exists in listofsensorsId, go to next value
                        if(@list.get(l) == listOfSensorId[i]) {
                            alreadyExists = true;
                        }
                    }
                    // if the data list member didn't exist in the sensor list, add it in
                    if (alreadyExists == false) {
                        listOfSensorId.push(@list.get(l));
                    // Finally, we reset already exist to test the next value
                    } else {
                        alreadyExists = false;                    
                    }
                }
            }
            
            // We get the number of sensors
            var nbrOfSensors = listOfSensorId.length;

            //Now, we dynamically create as much chartData var as there are sensors
            for (i = 1; i < nbrOfSensors+1; i++) {
                eval("var chartData" + i + " = []");
            }
            
            var id;
            var dateMinus;
            var newDate;
            var newDateSplit;
            var time;
            var value;
             
            // THis could be optimized by parsing this data at the same time as we counted the number of different IDs sooner
            @for(l <- 4 until list.size) {
                @if(l%4 == 0) {
                    // Here we have an ID
                    id = @list.get(l);
                }
                @if(l%4 == 1) {
                    // Here we have a date
                    dateMinus = "@list.get(l)";
                }
                @if(l%4 == 2) {
                    // Here we have a time
                    time = "@list.get(l)".slice(0,-3);
                    
                    // get the date to the correct format "YYYY-DD-MM HH:MM"
                    newDate = dateMinus + " " + time;
                    //newDateSpl = "newDate".split("-", " ", ":");

                }
                @if(l%4 == 3) {
                    // Here we have the value
                    value = @list.get(l);
  
                    // Now that we got every values needed, we can push the data in the correct array
                    eval("chartData" + id + ".push({\
                         date: " + "newDate" +",\
                         tonsOfBananas: " + value +"\
                         });");
                }
            }
            var maxX = Math.max(d3.max(d3.values(chartData1)), d3.max(d3.values(chartData2)));
            var minX = Math.max(d3.min(d3.values(chartData1)), d3.min(d3.values(chartData2)));                           
            // Initiate chart creation
            var vis = d3.select('#visualisation'),
                width = 1000,
                height = 500,
                margins = {
                    top: 20,
                    right: 20,
                    bottom: 20,
                    left: 50
                },
                yScale = d3.scale.linear().range([height - margins.top, margins.bottom]).domain([minX,maxX]),
                xScale = d3.scale.linear().range([height - margin.top, margins.bottom]).domain([minY, maxY]),
                    
        </script>
            <div class="container">
                <div class="jumbotron">
                </div>
                
                <svg id="visualisation" width="1000" height="500"></svg>

            </div>
                
    </body>
</html>