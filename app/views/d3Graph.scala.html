@(list: List[String])

<!DOCTYPE html>
<html lang="en">
    <head>
        <title>WHAT ARE YOU DOING STALKER</title>
        <link rel="stylesheet" media="screen" href="@routes.Assets.versioned("stylesheets/main.css")">
        <link href="@routes.Assets.versioned("stylesheets/css/bootstrap.min.css")" rel="stylesheet">
        <link href="http://getbootstrap.com/examples/justified-nav/justified-nav.css" rel="stylesheet">
        <script src="@routes.Assets.versioned("javascripts/d3.min.js")" type="text/javascript"></script>
    </head>
    
    <style>

        * {
            padding: 0;
            margin: 0;
        }

        html, body {
            height: 100%;
        }

        path {
            fill: none;
            stroke: black;
        }

        svg {
            display: block;
            width: 100%;
            height: 100%;
        }

        svg .data-point {
            stroke: blue;
            stroke-width: 1.5px;
            fill: blue;        
        }

        svg .data-point-text {
            font-family: sans-serif;
            font-size: 11px;
            fill: red;
        }

        svg .axis path, 
        svg .axis line {
            fill: none;
            stroke: black;
        }

        svg .axis text {
            font-family: sans-serif;
            font-size: 11px;
        }
    </style>
    <body>
        <!-- Create two empty Object array and append as much unmutable array to it as there are values in the cvs document-->
        <script type="text/javascript">
            //First, let's see how many sensors there are
            var listOfSensorId = [];
            var alreadyExists = false;
            var i;
            // goes through every members of the data arraylist
            @for(l <- 0 until list.size) {
                // checks every 4 members, except the ery first which is text (= every Ids)
                
                @if(l%4 == 0 && l != 0) {
                    // checks every embers of listofSensorId
                    for(i = 0; i < listOfSensorId.length; i++) {
                        // if the list members exists in listofsensorsId, go to next value
                        if(@list.get(l) == listOfSensorId[i]) {
                            alreadyExists = true;
                        }
                    }
                    // if the data list member didn't exist in the sensor list, add it in
                    if (alreadyExists == false) {
                        listOfSensorId.push(@list.get(l));
                    // Finally, we reset already exist to test the next value
                    } else {
                        alreadyExists = false;                    
                    }
                }
            }
            
            // We get the number of sensors
            var nbrOfSensors = listOfSensorId.length;

            //Now, we dynamically create as much chartData var as there are sensors
            for (i = 1; i < nbrOfSensors+1; i++) {
                eval("var chartData" + i + " = []");
            }
            
            var id;
            var dateMinus;
            var newDate;
            var newDateSplit;
            var time;
            var value;
             
            // THis could be optimized by parsing this data at the same time as we counted the number of different IDs sooner
            @for(l <- 4 until list.size) {
                @if(l%4 == 0) {
                    // Here we have an ID
                    id = @list.get(l);
                }
                @if(l%4 == 1) {
                    // Here we have a date
                    dateMinus = "@list.get(l)";
                }
                @if(l%4 == 2) {
                    // Here we have a time
                    time = "@list.get(l)".slice(0,-3);
                    
                    // get the date to the correct format "YYYY-DD-MM HH:MM"
                    newDate = dateMinus + " " + time;
                    //newDateSpl = "newDate".split("-", " ", ":");

                }

                var parseDate = d3.time.format("%Y-%m-%d %H:%M").parse;
                @if(l%4 == 3) {
                    // Here we have the value
                    value = @list.get(l);

  
                    // Now that we got every values needed, we can push the data in the correct array
                    eval("chartData" + id + ".push({\
                         date: " + "newDate" +",\
                         tonsOfBananas: " + value +"\
                         });");
                }
            }

                                     
            // Initiate chart creation
            var width = 500;
            var height = 250;

            // Create the SVG 'canvas'
            var svg = d3.select("body")
                    .append("svg")
                    .attr("viewBox", "0 0 " + width + " " + height)  

            /// Define the padding around the graph
            var padding = 50;


            // Get the min/max of each axis & the scales
            var maxY = Math.max((d3.max(chartData1, function(d) { return d.tonsOfBananas;})), (d3.max(chartData2, function(d) { return d.tonsOfBananas;})));
            var minY = Math.min((d3.min(chartData1, function(d) { return d.tonsOfBananas;})), (d3.min(chartData2, function(d) { return d.tonsOfBananas;})));

            var maxX = d3.max(chartData1, function(d) { return d.date;});
            var minX = d3.min(chartData1, function(d) { return d.date;});

            // Get the scales
            var xScale = d3.time.scale()
                    .range([padding, width - padding])
                    .domain([minX,maxX]);

            var yScale = d3.scale.linear()
                    .range([height - padding, padding])
                    .domain([0, maxY]);

            // x axis
            var format = d3.time.format("%Y-%m-%d %H:%M");
            var parseDate = d3.time.format("%Y-%m-%d %H:%M").parse;
            var xAxis = d3.svg.axis()
                    .scale(xScale)
                    .orient("bottom")
                    .tickFormat(format)
                    .ticks(47);

            svg.append("g")
                    .attr("class", "x axis")
                    .attr("transform", "translate(0," + height + ")")
                    .call(xAxis);
            
            // y axis
            var yAxis = d3.svg.axis()
                    .scale(yScale)
                    .orient("left")
                    .tickFormat(function(d) {return d})
                    .ticks(5);

            svg.append("g")
                    .attr("class", "y axis")
                    .call(yAxis);


            // Draw line graph
            var line = d3.svg.line()
                    .x(function(d) {
                        return xScale(d.date);
                    })
                    .y(function(d) {
                        return yScale(d.tonsOfBananas);
                    });

            svg.append("svg:path").attr("d", line(chartData1));

            svg.selectAll("circle")
                    .data(chartData1)
                    .enter()
                    .append("circle")
                    .attr("class", "data-point")
                    .attr("cx", function(d) {
                        return xScale(parseDate(d.date));
                    })
                    .attr("cy", function(d) {
                        return yScale(d.tonsOfBananas);
                    })
                    .attr("r", 0.25);
                       
        </script>
            <div class="container">
                <div class="jumbotron">
                </div>
                
                <svg id="visualisation" width="1000" height="500"></svg>

            </div>
                
    </body>
</html>